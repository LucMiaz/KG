\subsection{Reproducing the calculations}
The following calculations are done by calling data stored in a neo4j graph database from R. To insert data in this database, first use {\tt main\_ analysis.py} to generate a serie of json file containing all the useful info on your new data. Then use the code {\tt toDB.py} to import these data in the neo4j database -- before running the script, please read the head lines and make the necessary changes described there.

In R, the database is called as follows -- don't forget to launch the neo4j interface and start the local server if necessary :

<<Call of the database>>=
library(RNeo4j)#call RNeo4j package
graph=startGraph('http://localhost:7474/db/data', username='neo4j', password='admin')#opens a port to the db, with username 'neo4j' and password 'admin'
#to access the database click this link : 'http://neo4j:admin@localhost:7474/db/data'
@

\subsubsection{Structure of the database}

The databases in Neo4j are graphs, containing nodes and relationships between these nodes. Nodes and relationships have types (or labels). This will differentiate between Passings and Algorithms, in the case of Nodes, and between the relation of seeing (Passing saw this type of train) and the relation of taking place there (Passing took place here). To gain insight of this database please look at figure \ref{fig:neo4jdb} and at the structure in appendice {\ref{ssec:app:neo4jstruct}} on page {\pageref{ssec:app:neo4jstruct}}.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/graph.pdf}
\label{graphneo4j}
\caption{\label{fig:neo4jdb}Illustration of the nodes and relationships types in the Neo4j database.}
\end{figure}

\subsection{Getting started in R}

We will import the measurements for all the algorithms. RNeo4j accepts {\tt data.frames} as input, so we will give it that. In the following R-code, we will call all evaluations made with the algorithms in the database, all Passings attached to those evaluations and all trains types of those Passings.

<<Data query>>=
query='
MATCH (a:Algorithm)
MATCH (b)<-[s:ISANEVALOF]-(c)-[:WASEVALWITH]->(a)//the relationship s contains the specific lengths of time (masked and not) of the microphone signal (c)
MATCH (t)<-[r:SAW]-(b)//the relationship r contains info on the train of this Passing (lenght and track)
RETURN a.Name, c.tNoisemasked, c.tNoise, s.tEval, s.tEvalmasked, t.Name, r.trainLength, r.Track
'
q<-cypher(graph,query)#takes the info of each MicMes for one algorithm
@
<<arrage, include=FALSE>>=
q<- q %>% arrange(a.Name)
@
<<Evalsummary, include=FALSE, results='asis'>>=
tabqEval <- xtable(q %>% summary(s.tEval), digits=c(0,3,3,0,0,3,3,0,2),caption='Summary of the evaluated time.', label='tab:Eval')
print(tabqEval,type="latex")
@
<<Noisesummary, include=FALSE, results='asis'>>=
tabqNoise <- xtable(q %>% summary(c.tNoise), digits=c(0,3,3,0,0,3,3,0,2),caption='Summary of the Noise time.', label='tab:Noise')
print(tabqNoise,type="latex")
@
<<Evalmaskedsummary, include=FALSE, results='asis'>>=
tabqmaskedEval <- xtable(q %>% summary(s.tEvalmasked), digits=c(0,3,3,0,0,3,3,0,2),caption='Summary of the evaluated time masked.', label='tab:Evalmasked')
print(tabqmaskedEval,type="latex")
@
<<Noisemaskedsummary, include=FALSE, results='asis'>>=
tabqNoisemasked <- xtable(q %>% summary(c.tNoise), digits=c(0,3,3,0,0,3,3,0,2),caption='Summary of the Noise time on the masked subrange.', label='tab:Noisemasked')
print(tabqNoisemasked,type="latex")
@
